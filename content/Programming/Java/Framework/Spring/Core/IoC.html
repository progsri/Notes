<h2><strong> Inversion of Control  </strong></h2>
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Inversion of control </strong></h4>
<p>
   Instead of the we defining explicitly the objects and their behavior, we can ask Spring container  to create the object and
   provide us that object via the applicationContext. Spring container can provide the same object( singleton ) or different
   object( prototype ) each time we request.
</p>
<!----------------- Another Topic ------------------->
<hr>
<h4><strong> Dependency injection </strong></h4>
<p>
 Spring container will inject the dependency objects that are required by our class.
</p>
<p>
  Can do it either thru constructor or setter. Imagine a class C which depend on class B which internally depends on A.
   Then spring container creates A object and autowires the A object into B object by constructor or setter and then
   autowires B object into C object by constructor or setter.
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> IoC Container </strong></h4>
<p>
   ApplicationContext represents the IoC Container. It would have all the beans( objects created by spring ) instantiated for the 
   application. Beans can be create via XML file or Java annotations.
</p>
<p>
   To be all th beans created in the IoC, we need to Inject or Autowire <code> ApplicationContext </code>, it can be autowired to any 
   class as below
   <pre class="language-java line-numbers"><code>
   @RestController
   public class Api {

    @Autowired
    private ApplicationContext applicationContext;

    @GetMapping(value = "/api")
    public String getCities() {
        StringBuilder result = new StringBuilder();
        for ( String bean : applicationContext.getBeanDefinitionNames() ){
            result.append(bean).append("\n").append("\n");
        }
        return result.toString();
    }
}
   </code></pre>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Creating Beans </strong></h4>
<p>
   By default, beans created are <mark> singleton </mark>
</p>
<h6><strong> Method 1 </strong></h6>
<p>
   By annotation <code>@Component</code> and it's variances, Spring would create the objects/beans.This is used when developer has
   control over the source code where can annotate with appropriate @Autowire/@Component/@Controller/@Service.
   
   <pre class="language-java line-numbers"><code>
      @Component
      public class BeanA {

      }
      
      @Component
      public class BeanB {
      
         @Autowire
         private BeanA beanA;
         
      }
      // Here spring would first create BeanA as BeanB is dependent on it and then create BeanB and inject/autowire BeanA.
      
    </code></pre>
</p>
<h6><strong> Method 2 </strong></h6>
<p>
   By annotation <code>@Configuration/@Bean</code>, the developer would return the object created under the method annotated with
   @Bean, this is used when we do not have source code but we have to create beans with specific properties such as datasource,
   connection pool config etc.
   
   <pre class="language-java line-numbers"><code>
      // Make sure this class is in the component scan of Spring. Once spring see @Configuration, it will start
      // creating the beans.
      @Configuration 
      public class Config {
      
         @Bean
         public BeanA createBeanA(){
            return new BeanA();
         }

      }
   </code></pre>
   
</p>
<h6><strong> Method 3 </strong></h6>
<p>
   We can provide Spring with a static factory method, it has to be a static method otherwise spring cannot call it. Then this method
   is responsbile for creating the bean.  <span class="text-danger"> When is this used </span>
</p>
<h6><strong> Method 4 </strong></h6>
<p>
   We can also provide spring with a instance factory method, for that w first have to create a bean either by @Component or @Bean and 
   then provide a method in that bean which would create the necessary beans.  <span class="text-danger"> When is this used </span>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Autowiring ( Dependency Injection ) </strong></h4>
<p>
   <span class="text-danger"> Benefits </span>
</p>
<h6><strong> Method 1 - Constructor based </strong></h6>
<p>
   In the below code as ClassA is dependent on ClassB via the constructor argument, IoC first creates ClassB object <b> first </b> and 
   then while creating ClassA object with the ClassB as a dependency will injectvia ClassA's constructor.
</p>
<p>
   Used when you have mandatory dependencies as the dependencies are first created for later injection.
</p>
<p>
   If ClassA depends on ClassB and vice versa, circular dependency issue occurs as each one waits for the other bean to be created, this 
   does not happen in setter/property based injection.
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }

    @Autowired
    public ClassA(ClassB classB){
        this.classB = classB;
        System.out.println("Constructor of ClassA called with arg " + classB);
    }
}
</code></pre>

output
<pre class="language-sh line-numbers"><code>
Constructor of ClassB called.
Constructor of ClassA called with arg com.ninjashore.sample.Components.ClassB@2a2da905
</code></pre>

<!------------------------------------------------------------------->
<h6><strong> Method 2  - Setter based </strong></h6>
<p>
   Same as Property based 
</p>
<p>
   Observe that Class A and Class B are created seperately and then class B is injected into ClassA.
</p>
<p>
   Used when you have optional dependencies.
</p>
<p>
   if classA depends on classB and vice versa, then unlike constructor based injection circular dependency issue would not occur as
   the beans are created independently and the autowirng happens later via setter methods.
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }

    public ClassB getClassB() {
        return classB;
    }

    @Autowired
    public void setClassB(ClassB classB) {
        System.out.println("setting ClassB in ClassA");
        this.classB = classB;
    }
}
</code></pre>

output
<pre class="language-sh line-numbers"><code>
no arg Constructor of ClassA called.
Constructor of ClassB called.
setting ClassB in ClassA
</code></pre>

<!------------------------------------------------------------------->
<h6><strong> Method 2  - Property based </strong></h6>
<p>
   Same as Setter based 
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    @Autowired
    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }
}
</code></pre>
 
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Lazy initialized beans </b></h4>
<p> In general beans are created eagerly at startup </p>
<p> Works on Class, Method</p>
<p class="text-danger"> Works on Constructor, Field, Parameter</p>
<p> Lazy beans are initialized when they are requested </p>
<p> if another bean which is not lazyly initialized depends on the lazy initialized bean, then laziness is not applied </p>
<p> For a complete Laziness all the dependent beans should be maked with marked with <code> @Lazy </code> </p>

<pre class="language-java line-numbers"><code>
@Component
@Lazy
public class ClassLazy {

    public ClassLazy(){
        System.out.println("Constructor of ClassLazy");
    }

}
</code></pre>
 
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Method Injection </b></h4>
<p>
    When Singleton bean has a dependency on a singleton bean or a Prototype bean has a dependency on a singleton bean or a 
   prototype bean has a dependency on a prototype bean then the injection is straigth forward, but what happens when a singleton
   bean depends on a Prototype bean...the container when creating the singleton bean simply injects the Protype bean for the first time
   and when ever this singleton bean is used the old Protype bean is used which actually is <b> not </b> the Prototype behaviour as we 
   need a new bean each time.
</p>
<p class="text-danger">
   To solve this look at Method Injection or <code> @Lookup </code>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Scope of Bean </b></h4>

<h6><b> Singleton </b></h6>
<p> This is the default scope.  </p>
<p> <mark> A application can have multiple containers </mark>, so per container always returns the same object.</p>
<p> Good for stateless objects. </p>

<h6><b> Prototype </b></h6>
<p> Annotated as <code> @Scope("prototype") </code> along with <code> @Component </code> </p>
<p> When ever this object is requested, container creates a new bean. </p>
<p> Good for stateful objects. </p>
<p class="text-danger"> Destruction lifecycle callbacks are not called, it is upto the code to clean up the beans, for Spring to 
   clean up the beans use bean post processor.
</p>
<p> 
   when a singleton bean has a prototype bean autowired to it, this prototype bean is not created each time, to create a new bean 
   every time ...look at <b> Method injection or @Lookup </b>. 
</p>

<h6><b> Request </b></h6>
<p class="text-danger"> Need addtional configuration as it only works in <b> web aware </b> context.</p>
<p> Annotated as <code> @RequestScope </code>  along with <code> @Component </code> </p>
<p> Container creates a new bean for  each and every new HTTP request. So changes made in one request does not effect other request
   changes.
</p>
<p> When the request processing is completed, then this bean is discarded. </p>

<h6><b> Session </b></h6>
<p class="text-danger"> Need addtional configuration as it only works in <b> web aware </b> context.</p>
<p> Annotated as <code> @SessionScope </code>  along with <code> @Component </code> </p>
<p> Create a new bean per HTTP session. Changes made on the bean effects that session only, typically sessions are tracked using
   <code> JSESSIONID </code>. Would reuse the bean if the same session is used ( may be JSESSIONID in Header ) 
</p>
<p> This bean is discarded when the session is discarded. </p>



<!------------------------------------------------------------------------------------------------------------------------->
<hr>
