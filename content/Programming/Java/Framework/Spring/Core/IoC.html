<h2><strong> Inversion of Control  </strong></h2>
<!----------------- Another Topic ------------------->
<hr>

<h4><strong> Inversion of control </strong></h4>
<p>
   Instead of the we defining explicitly the objects and their behavior, we can ask Spring container  to create the object and
   provide us that object via the applicationContext. Spring container can provide the same object( singleton ) or different
   object( prototype ) each time we request.
</p>
<!----------------- Another Topic ------------------->
<hr>
<h4><strong> Dependency injection </strong></h4>
<p>
 Spring container will inject the dependency objects that are required by our class.
</p>
<p>
  Can do it either thru constructor or setter. Imagine a class C which depend on class B which internally depends on A.
   Then spring container creates A object and autowires the A object into B object by constructor or setter and then
   autowires B object into C object by constructor or setter.
</p>

<!----------------- Another Topic ------------------->
<hr>
<h4><strong> IoC Container </strong></h4>
<p>
   ApplicationContext represents the IoC Container. It would have all the beans( objects created by spring ) instantiated for the 
   application. Beans can be create via XML file or Java annotations.
</p>
<p>
   To be all th beans created in the IoC, we need to Inject or Autowire <code> ApplicationContext </code>, it can be autowired to any 
   class as below
   <pre class="language-java line-numbers"><code>
   @RestController
   public class Api {

    @Autowired
    private ApplicationContext applicationContext;

    @GetMapping(value = "/api")
    public String getCities() {
        StringBuilder result = new StringBuilder();
        for ( String bean : applicationContext.getBeanDefinitionNames() ){
            result.append(bean).append("\n").append("\n");
        }
        return result.toString();
    }
}
   </code></pre>
</p>

<!----------------- Another Topic ------------------->
<hr>
<h4><strong> Creating Beans </strong></h4>
<h6><strong> Method 1 </strong></h6>
<p>
   By annotation <code>@Component</code> and it's variances, Spring would create the objects/beans.This is used when developer has
   control over the source code where can annotate with appropriate @Autowire/@Component/@Controller/@Service.
   
   <pre class="language-java line-numbers"><code>
      @Component
      public class BeanA {

      }
      
      @Component
      public class BeanB {
      
         @Autowire
         private BeanA beanA;
         
      }
    </code></pre>
</p>
<h6><strong> Method 2 </strong></h6>
<p>
   By annotation <code>@Configuration/@Bean</code>, the developer would return the object created under the method annotated with
   @Bean, this is used when we do not have source code but we have to create beans with specific properties such as datasource,
   connection pool config etc.
   
   <pre class="language-java line-numbers"><code>
      @Configuration
      public class Config {
      
         @Bean
         public BeanA createBeanA(){
            return new BeanA();
         }

      }
   </code></pre>
   
</p>
<h6><strong> Method 3 </strong></h6>
<p>
   We can provide Spring with a static factory method, it has to be a static method otherwise spring cannot call it. Then this method
   is responsbile for creating the bean.  <span class="text-danger"> When is this used </span>
</p>
<h6><strong> Method 4 </strong></h6>
<p>
   We can also provide spring with a instance factory method, for that w first have to create a bean either by @Component or @Bean and 
   then provide a method in that bean which would create the necessary beans.  <span class="text-danger"> When is this used </span>
</p>
<!----------------- Another Topic ------------------->
<hr>
<h4><strong> Autowiring ( Dependency Injection ) </strong></h4>
<p>
   <span class="text-danger"> Benefits </span>
</p>
<h6><strong> Method 1 - Constructor based </strong></h6>
<p>
</p>
<h6><strong> Method 1 - Setter or Property based </strong></h6>
<p>
</p>

 
