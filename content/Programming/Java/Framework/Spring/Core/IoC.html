<h2><strong> Inversion of Control  </strong></h2>
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Inversion of control </strong></h4>
<p>
   Instead of the we defining explicitly the objects and their behavior, we can ask Spring container  to create the object and
   provide us that object via the applicationContext. Spring container can provide the same object( singleton ) or different
   object( prototype ) each time we request.
</p>
<!----------------- Another Topic ------------------->
<hr>
<h4><strong> Dependency injection </strong></h4>
<p>
 Spring container will inject the dependency objects that are required by our class.
</p>
<p>
  Can do it either thru constructor or setter. Imagine a class C which depend on class B which internally depends on A.
   Then spring container creates A object and autowires the A object into B object by constructor or setter and then
   autowires B object into C object by constructor or setter.
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> IoC Container </strong></h4>
<p>
   ApplicationContext represents the IoC Container. It would have all the beans( objects created by spring ) instantiated for the 
   application. Beans can be create via XML file or Java annotations.
</p>
<p>
   To be all th beans created in the IoC, we need to Inject or Autowire <code> ApplicationContext </code>, it can be autowired to any 
   class as below
   <pre class="language-java line-numbers"><code>
   @RestController
   public class Api {

    @Autowired
    private ApplicationContext applicationContext;

    @GetMapping(value = "/api")
    public String getCities() {
        StringBuilder result = new StringBuilder();
        for ( String bean : applicationContext.getBeanDefinitionNames() ){
            result.append(bean).append("\n").append("\n");
        }
        return result.toString();
    }
}
   </code></pre>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Creating Beans </strong></h4>
<p>
   By default, beans created are <mark> singleton </mark>
</p>
<h6><strong> Method 1 </strong></h6>
<p>
   By annotation <code>@Component</code> and it's variances, Spring would create the objects/beans.This is used when developer has
   control over the source code where can annotate with appropriate @Autowire/@Component/@Controller/@Service.
   
   <pre class="language-java line-numbers"><code>
      @Component
      public class BeanA {

      }
      
      @Component
      public class BeanB {
      
         @Autowire
         private BeanA beanA;
         
      }
      // Here spring would first create BeanA as BeanB is dependent on it and then create BeanB and inject/autowire BeanA.
      
    </code></pre>
</p>
<h6><strong> Method 2 </strong></h6>
<p>
   By annotation <code>@Configuration/@Bean</code>, the developer would return the object created under the method annotated with
   @Bean, this is used when we do not have source code but we have to create beans with specific properties such as datasource,
   connection pool config etc.
   
   <pre class="language-java line-numbers"><code>
      // Make sure this class is in the component scan of Spring. Once spring see @Configuration, it will start
      // creating the beans.
      @Configuration 
      public class Config {
      
         @Bean
         public BeanA createBeanA(){
            return new BeanA();
         }

      }
   </code></pre>
   
</p>
<h6><strong> Method 3 </strong></h6>
<p>
   We can provide Spring with a static factory method, it has to be a static method otherwise spring cannot call it. Then this method
   is responsbile for creating the bean.  <span class="text-danger"> When is this used </span>
</p>
<h6><strong> Method 4 </strong></h6>
<p>
   We can also provide spring with a instance factory method, for that w first have to create a bean either by @Component or @Bean and 
   then provide a method in that bean which would create the necessary beans.  <span class="text-danger"> When is this used </span>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Autowiring ( Dependency Injection ) </strong></h4>
<p>
   <span class="text-danger"> Benefits </span>
</p>
<h6><strong> Method 1 - Constructor based </strong></h6>
<p>
   In the below code as ClassA is dependent on ClassB via the constructor argument, IoC first creates ClassB object <b> first </b> and 
   then while creating ClassA object with the ClassB as a dependency will injectvia ClassA's constructor.
</p>
<p>
   Used when you have mandatory dependencies as the dependencies are first created for later injection.
</p>
<p>
   If ClassA depends on ClassB and vice versa, circular dependency issue occurs as each one waits for the other bean to be created, this 
   does not happen in setter/property based injection.
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }

    @Autowired
    public ClassA(ClassB classB){
        this.classB = classB;
        System.out.println("Constructor of ClassA called with arg " + classB);
    }
}
</code></pre>

output
<pre class="language-sh line-numbers"><code>
Constructor of ClassB called.
Constructor of ClassA called with arg com.ninjashore.sample.Components.ClassB@2a2da905
</code></pre>

<!------------------------------------------------------------------->
<h6><strong> Method 2  - Setter based </strong></h6>
<p>
   Same as Property based 
</p>
<p>
   Observe that Class A and Class B are created seperately and then class B is injected into ClassA.
</p>
<p>
   Used when you have optional dependencies.
</p>
<p>
   if classA depends on classB and vice versa, then unlike constructor based injection circular dependency issue would not occur as
   the beans are created independently and the autowirng happens later via setter methods.
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }

    public ClassB getClassB() {
        return classB;
    }

    @Autowired
    public void setClassB(ClassB classB) {
        System.out.println("setting ClassB in ClassA");
        this.classB = classB;
    }
}
</code></pre>

output
<pre class="language-sh line-numbers"><code>
no arg Constructor of ClassA called.
Constructor of ClassB called.
setting ClassB in ClassA
</code></pre>

<!------------------------------------------------------------------->
<h6><strong> Method 2  - Property based </strong></h6>
<p>
   Same as Setter based 
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    @Autowired
    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }
}
</code></pre>
 
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Lazy initialized beans </b></h4>
<p> In general beans are created eagerly at startup </p>
<p> Works on Class, Method</p>
<p class="text-danger"> Works on Constructor, Field, Parameter</p>
<p> Lazy beans are initialized when they are requested </p>
<p> if another bean which is not lazyly initialized depends on the lazy initialized bean, then laziness is not applied </p>
<p> For a complete Laziness all the dependent beans should be maked with marked with <code> @Lazy </code> </p>

<pre class="language-java line-numbers"><code>
@Component
@Lazy
public class ClassLazy {

    public ClassLazy(){
        System.out.println("Constructor of ClassLazy");
    }

}
</code></pre>
 
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Method Injection </b></h4>
<p>
    When Singleton bean has a dependency on a singleton bean or a Prototype bean has a dependency on a singleton bean or a 
   prototype bean has a dependency on a prototype bean then the injection is straigth forward, but what happens when a singleton
   bean depends on a Prototype bean...the container when creating the singleton bean simply injects the Protype bean for the first time
   and when ever this singleton bean is used the old Protype bean is used which actually is <b> not </b> the Prototype behaviour as we 
   need a new bean each time.
</p>
<p class="text-danger">
   To solve this look at Method Injection or <code> @Lookup </code>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Scope of Bean </b></h4>

<h5><b> -- Singleton </b></h5>
<p> This is the default scope.  </p>
<p> <mark> A application can have multiple containers </mark>, so per container always returns the same object.</p>
<p> Good for stateless objects. </p>

<!----------------------------------------->

<h5><b> -- Prototype </b></h5>
<p> Annotated as <code> @Scope("prototype") </code> along with <code> @Component </code> </p>
<p> When ever this object is requested, container creates a new bean. </p>
<p> Good for stateful objects. </p>
<p class="text-danger"> Destruction lifecycle callbacks are not called, it is upto the code to clean up the beans, for Spring to 
   clean up the beans use bean post processor.
</p>
<p> 
   when a singleton bean has a prototype bean autowired to it, this prototype bean is not created each time, to create a new bean 
   every time ...look at <b> Method injection or @Lookup </b>. 
</p>

<!----------------------------------------->

<h5><b> -- Request </b></h5>
<p class="text-danger"> Need addtional configuration as it only works in <b> web aware </b> context.</p>
<p> Annotated as <code> @RequestScope </code>  along with <code> @Component </code> </p>
<p> Container creates a new bean for  each and every new HTTP request. So changes made in one request does not effect other request
   changes.
</p>
<p> When the request processing is completed, then this bean is discarded. </p>
<p class="text-danger"> When injecting a short lived bean into a long lived bean, in order to get the new short lived bean each time use  
   <b> aop:scoped-proxy </b>
</p>

<!----------------------------------------->

<h5><b> -- Session </b></h5>
<p class="text-danger"> Need addtional configuration as it only works in <b> web aware </b> context.</p>
<p> Annotated as <code> @SessionScope </code>  along with <code> @Component </code> </p>
<p> Create a new bean per HTTP session. Changes made on the bean effects that session only, typically sessions are tracked using
   <code> JSESSIONID </code>. Would reuse the bean if the same session is used ( may be JSESSIONID in Header ) 
</p>
<p> This bean is discarded when the session is discarded. </p>
<p class="text-danger"> When injecting a short lived bean into a long lived bean, in order to get the new short lived bean each time use  
   <b> aop:scoped-proxy </b>
</p>

<!----------------------------------------->

<h5><b class="text-danger"> -- Application </b></h5>
<p class="text-danger"> Need addtional configuration as it only works in <b> web aware </b> context.</p>
<p> Annotated as <code> @ApplicationScope </code>  along with <code> @Component </code> </p>

<!----------------------------------------->

<h5><b> -- Custom </b></h5>
<p> We can create our own custom scope by implementing <code> org.springframework.beans.factory.config.Scope </code> interface </p>


<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> LifeCycle Callbacks </b></h4>

<h5><b> -- Initialization  </b></h5>
<p> Helps to call a bean method just after the bean is created </p>
<p> use <code> @PostConstruct </code> on a method to invoke just after the bean is created or constructed </p>
<p> use <code> init-method </code> in xml configuration </p>
<p class="tet-danger"> can be used to assign instance values to the static members in a bean </p> 

Usage of  @PostConstruct
<pre class="language-java line-numbers"><code>
@Component
public class ClassC {

   {
        System.out.println("Static block of Class C");
    }

    public ClassC(){
        System.out.println("Constructor of ClassC called.");
    }

    @PostConstruct
    public void test(){
        System.out.println("Post Construct");
    }


}
</code></pre>

<pre class="language-java line-numbers"><code>
Static block of Class C
Constructor of ClassC called.
Post Construct
</code></pre>

<p> Instead of @PostConstruct we can also use Spring interface <code> org.springframework.beans.factory.InitializingBean </code> </p>
<p> Prefer @PostConstruct over InitializingBean as PostConstruct is part of <b> javax </b> so less dependency on Spring framework.</p>

Usage of  InitializingBean
<pre class="language-java line-numbers"><code>
@Component
public class ClassC implements InitializingBean {

   {
        System.out.println("Static block of Class C");
    }

    public ClassC(){
        System.out.println("Constructor of ClassC called.");
    }
   
   public void afterPropertiesSet() throws Exception {
        System.out.println("afterPropertiesSet");
    }
}
</code></pre>

<pre class="language-java line-numbers"><code>
Static block of Class C
Constructor of ClassC called.
afterPropertiesSet
</code></pre>

<p> Initialiation callbacks are called for singleton, Prototype beans </p>
<p class="text-danger"> Are initialiation callbacks called for request, session, application, custom scoped beans </p>
<p> we can have both PostConstruct and InitializingBean in a class in that case PostConstruct method is executed first and then
   then the afterPropertiesSet() of InitializingBean is executed
</p>

<!----------------------------------------->

<h5><b> -- Destruction  </b></h5>
<p> Called before a bean is being destroyed. </p>
<p> use <code> @PreDestroy </code> is used in annotation based or <code> destroy-method </code> in xml config  or use
<code> Disposable </code> interface on a class.
</p>
<p>
   Prefer  <b> @PreDestroy </b>  over <b>  Disposable </b> asit is part of <b> javax </b> so less dependency on Spring framework.
</p>
<p>
   Destruction callbacks are not called for the protoype beans <span class="text-danger"> WHY ??? </span>
</p>
<p>
  we can have @PreDestroy and Disposable interface method in class in that case @PreDestroy method is executed first and then the
   destroy method of Disposable interface is executed.
</p>


<h5><b class="text-danger"> -- Startup  </b></h5>

<!----------------------------------------->

<h5><b class="text-danger"> -- Shutdown  </b></h5>


<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Aware Callbacks </b></h4>


<!------------------------------------------------------------------------------------------------------------------------->
<hr>
