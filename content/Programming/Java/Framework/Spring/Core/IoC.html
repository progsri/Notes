<h2><strong> Inversion of Control  </strong></h2>
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Inversion of control </strong></h4>
<p>
   Instead of the we defining explicitly the objects and their behavior, we can ask Spring container  to create the object and
   provide us that object via the applicationContext. Spring container can provide the same object( singleton ) or different
   object( prototype ) each time we request.
</p>
<!----------------- Another Topic ------------------->
<hr>
<h4><strong> Dependency injection </strong></h4>
<p>
 Spring container will inject the dependency objects that are required by our class.
</p>
<p>
  Can do it either thru constructor or setter. Imagine a class C which depend on class B which internally depends on A.
   Then spring container creates A object and autowires the A object into B object by constructor or setter and then
   autowires B object into C object by constructor or setter.
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> IoC Container </strong></h4>
<p>
   ApplicationContext represents the IoC Container. It would have all the beans( objects created by spring ) instantiated for the 
   application. Beans can be create via XML file or Java annotations.
</p>
<p>
   To be all th beans created in the IoC, we need to Inject or Autowire <code> ApplicationContext </code>, it can be autowired to any 
   class as below
   <pre class="language-java line-numbers"><code>
   @RestController
   public class Api {

    @Autowired
    private ApplicationContext applicationContext;

    @GetMapping(value = "/api")
    public String getCities() {
        StringBuilder result = new StringBuilder();
        for ( String bean : applicationContext.getBeanDefinitionNames() ){
            result.append(bean).append("\n").append("\n");
        }
        return result.toString();
    }
}
   </code></pre>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Creating Beans </strong></h4>
<p>
   By default, beans created are <mark> singleton </mark>
</p>
<h6><strong> Method 1 </strong></h6>
<p>
   By annotation <code>@Component</code> and it's variances, Spring would create the objects/beans.This is used when developer has
   control over the source code where can annotate with appropriate @Autowire/@Component/@Controller/@Service.
   
   <pre class="language-java line-numbers"><code>
      @Component
      public class BeanA {

      }
      
      @Component
      public class BeanB {
      
         @Autowire
         private BeanA beanA;
         
      }
      // Here spring would first create BeanA as BeanB is dependent on it and then create BeanB and inject/autowire BeanA.
      
    </code></pre>
</p>
<h6><strong> Method 2 </strong></h6>
<p>
   By annotation <code>@Configuration/@Bean</code>, the developer would return the object created under the method annotated with
   @Bean, this is used when we do not have source code but we have to create beans with specific properties such as datasource,
   connection pool config etc.
   
   <pre class="language-java line-numbers"><code>
      // Make sure this class is in the component scan of Spring. Once spring see @Configuration, it will start
      // creating the beans.
      @Configuration 
      public class Config {
      
         @Bean
         public BeanA createBeanA(){
            return new BeanA();
         }

      }
   </code></pre>
   
</p>
<h6><strong> Method 3 </strong></h6>
<p>
   We can provide Spring with a static factory method, it has to be a static method otherwise spring cannot call it. Then this method
   is responsbile for creating the bean.  <span class="text-danger"> When is this used </span>
</p>
<h6><strong> Method 4 </strong></h6>
<p>
   We can also provide spring with a instance factory method, for that w first have to create a bean either by @Component or @Bean and 
   then provide a method in that bean which would create the necessary beans.  <span class="text-danger"> When is this used </span>
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> Autowiring ( Dependency Injection ) </strong></h4>
<p>
   <span class="text-danger"> Benefits </span>
</p>
<h6><strong> Method 1 - Constructor based </strong></h6>
<p>
   In the below code as ClassA is dependent on ClassB via the constructor argument, IoC first creates ClassB object <b> first </b> and 
   then while creating ClassA object with the ClassB as a dependency will injectvia ClassA's constructor.
</p>
<p>
   Used when you have mandatory dependencies as the dependencies are first created for later injection.
</p>
<p>
   If ClassA depends on ClassB and vice versa, circular dependency issue occurs as each one waits for the other bean to be created, this 
   does not happen in setter/property based injection.
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }

    @Autowired
    public ClassA(ClassB classB){
        this.classB = classB;
        System.out.println("Constructor of ClassA called with arg " + classB);
    }
}
</code></pre>

output
<pre class="language-sh line-numbers"><code>
Constructor of ClassB called.
Constructor of ClassA called with arg com.ninjashore.sample.Components.ClassB@2a2da905
</code></pre>

<!------------------------------------------------------------------->
<h6><strong> Method 2  - Setter based </strong></h6>
<p>
   Same as Property based 
</p>
<p>
   Observe that Class A and Class B are created seperately and then class B is injected into ClassA.
</p>
<p>
   Used when you have optional dependencies.
</p>
<p>
   if classA depends on classB and vice versa, then unlike constructor based injection circular dependency issue would not occur as
   the beans are created independently and the autowirng happens later via setter methods.
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }

    public ClassB getClassB() {
        return classB;
    }

    @Autowired
    public void setClassB(ClassB classB) {
        System.out.println("setting ClassB in ClassA");
        this.classB = classB;
    }
}
</code></pre>

output
<pre class="language-sh line-numbers"><code>
no arg Constructor of ClassA called.
Constructor of ClassB called.
setting ClassB in ClassA
</code></pre>

<!------------------------------------------------------------------->
<h6><strong> Method 2  - Property based </strong></h6>
<p>
   Same as Setter based 
</p>
<pre class="language-java line-numbers"><code>

@Component
public class ClassB {
    public  ClassB(){
        System.out.println("Constructor of ClassB called.");
    }
}

@Component
public class ClassA {

    @Autowired
    private ClassB classB;

    public ClassA(){
        System.out.println("no arg Constructor of ClassA called.");
    }
}
</code></pre>
 
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> Lazy initialized beans </b></h4>
<p> In general beans are created eagerly at startup </p>
<p> Works on Class, Method</p>
<p class="text-danger"> Works on Constructor, Field, Parameter</p>
<p> Lazy beans are initialized when they are requested </p>
<p> if another bean which is not lazyly initialized depends on the lazy initialized bean, then laziness is not applied </p>
<p> For a complete Laziness all the dependent beans should be maked with marked with <code> @Lazy </code> </p>

<pre class="language-java line-numbers"><code>
@Component
@Lazy
public class ClassLazy {

    public ClassLazy(){
        System.out.println("Constructor of ClassLazy");
    }

}
</code></pre>
 

<!------------------------------------------------------------------------------------------------------------------------->
<hr>
