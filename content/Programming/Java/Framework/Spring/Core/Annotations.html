<h2><strong> Annotations </strong></h2>
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> @Configuration </strong></h4>
<p> works only on a Class </p>
<p>
  Used to indicate the class that create the Java beans
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> @Bean </strong></h4>
<p> works only on a method </p>
<p>
  Used to indicate a Java bean, use <code> @Configuration </code> on the class that has the @Bean method.
</p>
<pre class="language-java line-numbers"><code>
@Configuration
public class ClassD {

    @Bean("dataSource")
    public void createDataSource(){
        System.out.println("Creating datasource");
    }
}
</code></pre>

<p class="text-danger">
  Can be used with @Component as well in this case Spring would not use CGLIB proxying as it did with <code> @Configuration </code>
</p>

<p class="text-danger">
   If the method marked with @Bean in the class marked with @Configuration is static then Spring would not use CGLIB proxying.
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Autowired </b></h4>
<p>
  <code> @Inject </code> can also be used.
</p>
<p> 
  can be used for constructor / setter / property injection of the dependency bean into the dependent bean.
</p>
<p class="text-danger"> Autowiring list of values </p>

<p class="text-danger"> Autowiring a map </p>

<p class="text-danger"> Using Generics as Autowiring Qualifiers </p>

<p> <code> @Resource </code> can be used in place of @Autowired it looks like <code> @Autowired </code> is much more powerful.</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> @DependsOn </strong></h4>
<p> Used when one bean depends indirectly on other bean, if there is a direct dependency we can autowire.</p>
<p> Also used sometimes we can add <code> @Autowire </code> as we cannot modify the source code. </p>
<p> <b> Creation order </b> Dependent beans are created first. </p>
<p> <b> Destruction order </b> Independent beans are destroyed first. </p>

<pre class="language-java line-numbers"><code>
@Configuration
public class ClassD {

    @Bean("dataSource")
    public void createDataSource(){
        System.out.println("Creating datasource");
    }

    @Bean
    @DependsOn("dataSource")
    public void handleDataSource(){
        System.out.println("looking for the bean named datasource");
    }

}
</code></pre>

<p> Here until bean dataSource is created, bean handleDataSource will not be created as it depends on it.</p>

<pre class="language-sh line-numbers"><code>
Creating datasource
looking for the bean named datasource
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Lazy </b></h4>
<p> In general beans are created eagerly at startup </p>
<p> Works on Class, Method</p>
<p class="text-danger"> Works on Constructor, Field, Parameter</p>
<p> Lazy beans are initialized when they are requested </p>
<p> if another bean which is not lazyly initialized depends on the lazy initialized bean, then laziness is not applied </p>
<p> For a complete Laziness all the dependent beans should be maked with marked with <code> @Lazy </code> </p>

<pre class="language-java line-numbers"><code>
@Component
@Lazy
public class ClassLazy {

    public ClassLazy(){
        System.out.println("Constructor of ClassLazy");
    }

}
</code></pre>


<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong class="text-danger"> @Lookup </strong></h4>
<p> Also called Method Injection </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Scope </b></h4>
<p> Refer </p>
<p> takes argument on the type of the scope such as singleton, prototype </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @RequestScope </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @SessionScope </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @ApplicationScope </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @PostConstruct </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @PreDestroy</b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Primary </b></h4>
<p> 
  Without @Primary Spring would fail as Spring would find 2 beans of the same type, So by adding @Primary to one of the bean, we can
  tell Spring to use that in such scenarios.
</p>


<pre class="language-java line-numbers"><code>
@Component
@Primary
public class Type1 implements CommonType {

    public Type1(){
        System.out.println(
                "Type1 constructor"
        );
    }
}

@Component
public class Type2 implements CommonType {

    public Type2(){
        System.out.println("Type 2 constructor");
    }
}

@Component
public class Type3 {

    @Autowired
    private CommonType c1;

    @PostConstruct
    public void m1(){
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "Type3{" +
                "c1=" + c1 +
                '}';
    }
}

</code></pre>

Type1 bean is autowired.
<pre class="language-java line-numbers"><code>
Type3{c1=com.ninjashore.sample.Components.Type1@df3b78}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Qualifier  </b></h4>
<p> In case Spring find 2 or more beans of the same type we can use <code> @Qualifier </code> to mention which bean to pick,
  also you need to name the bean accordingly, if you do not name the bean then Spring names the name with the regular convention of
  small letter as small case, for example in the below code though I did not give Type2 class a name Spring named it as type2 and
  autowired it.
</p>

<pre class="language-java line-numbers"><code>
@Component("type1")
public class Type1 implements CommonType {

    public Type1(){
        System.out.println(
                "Type1 constructor"
        );
    }
}

@Component
public class Type2 implements CommonType {

    public Type2(){
        System.out.println("Type 2 constructor");
    }
}

@Component
public class Type3 {

    @Autowired
    @Qualifier("type2")
    private CommonType c1;

    @PostConstruct
    public void m1(){
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "Type3{" +
                "c1=" + c1 +
                '}';
    }
}

</code></pre>

Type 2 bean is autowired.
<pre class="language-java line-numbers"><code>
Type3{c1=com.ninjashore.sample.Components.Type2@df4b72}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @PropertySource  </b></h4>
<p> 
  By default properties are looked at <mark> application.properties </mark>, but if you want to change to a new properties file then
  you can acheive with this <code> @PropertySource("classpath:<new-file-name>") </code>. Create the new file in <mark> resources </mark>
</p>

<pre class="language-java line-numbers"><code>

@SpringBootApplication()
@PropertySource("classpath:test.properties")
public class SampleApplication2 {
    public static void main(final String[] args) {
        SpringApplication.run(SampleApplication2.class, args);
    }
}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Valid  - application properties </b></h4>
<p> 
  @valid looks for the property key at default location <mark> application.properties </mark> which can be changed by <code>
  @PropertySource </code>. To interpolate the value use <code> ${} </code>
</p>

<pre class="language-java line-numbers"><code>
@Component
public class ClassA2 {

    @Value("${p1}")
    private String p1;

    @PostConstruct
    public void m1(){
        System.out.println(this.p1);   /// Prints the value of p1 picked up application.properties.
    }
}
</code></pre>

<!----------------------------------------------------------->
<h4><b> @Valid  - system properties </b></h4>
<p> 
  <code> #{systemProperties['propertykey']} </code>  gives the system property value for propertykey.
</p>

<pre class="language-java line-numbers"><code>
@Component
public class ClassA2 {

    @Value("#{systemProperties['java.runtime.version']}")
    private String p1;

    @PostConstruct
    public void m1(){
        System.out.println(this.p1); // this would print the system property java.runtime.version=1.8.0_221-b11
    }
}

</code></pre>

<!----------------------------------------------------------->

<h4><b> @Valid  - JVM arguments </b></h4>
<p class="text-danger"> 
  How to read JVM argument
</p>

<!----------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @ComponentScan </b></h4>
<p>
  Takes the one or more package names for argument <code> basePackages </code>. Then Spring Container will look in the classpath for
  these packages, if found will look for spring defined annotation sucb as @Component, @Controller, @Service, @Configuration and perform
  the necessary steps.
</p>

<pre class="language-java line-numbers"><code>

@SpringBootApplication
@ComponentScan(basePackages = {"com.ninjashore.sample.Components","com.ninjashore.sample.OOP"})
public class Start {
    public static void main(final String[] args) {
        SpringApplication.run(Start.class, args);
    }
}

</code></pre>

<!----------------------------------------------------------->

<h4><b> @ComponentScan - includeFilters </b></h4>

<p>
  Using includeFilters we can include packages using <code> @Filter </code> type such as regex, aspectj or custom while performing
  the component scan, so Spring would only look under these packages.
</p>

<pre class="language-java line-numbers"><code>
@ComponentScan(basePackages = "org.example",includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository")
</code></pre>

<!----------------------------------------------------------->

<h4><b> @ComponentScan - excludeFilters </b></h4>

<p>
  Using excludeFilters we can exclude packages using <code> @Filter </code> type such as regex, aspectj or custom while performing
  the component scan, so Spring would not look under these packages.
</p>

<pre class="language-java line-numbers"><code>
@ComponentScan(basePackages = "org.example", excludeFilters = @Filter(Repository.class))
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------------->

<h4><b> @Filter </b></h4>
<p>
  Used with <code> @ComponentScan </code> to filter out the type of packages.
</p>


<!------------------------------------------------------------------------------------------------------------------------------->

<h4><b> @Import </b></h4>
<p>
  IT is used to import the <code> @Configuration </code> annotated java class. Sometimes when The @Configuration class is not in the 
  packages Spring is looking under then we can explicit import it.
</p>
<p>
  Also when we import a regular java class ( non @Configuration class )  with Spring annotations such as @Component etc... then
  Spring simply creates the bean.
</p>


<!------------------------------------------------------------------------------------------------------------------------------->

<h4><b> @ImportResource </b></h4>
<p>
   We can import  the old XML file using this.
</p>


<!------------------------------------------------------------------------------------------------------------------------------->

<h4><b class="text-danger"> @Required </b></h4>
<p>
 
</p>


<!------------------------------------------------------------------------------------------------------------------------------->

