<h2><strong> Annotations </strong></h2>
<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> @Configuration </strong></h4>
<p> works only on a Class </p>
<p>
  Used to indicate the class that create the Java beans
</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> @Bean </strong></h4>
<p> works only on a method </p>
<p>
  Used to indicate a Java bean, use <code> @Configuration </code> on the class that has the @Bean method.
</p>
<pre class="language-java line-numbers"><code>
@Configuration
public class ClassD {

    @Bean("dataSource")
    public void createDataSource(){
        System.out.println("Creating datasource");
    }
}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Autowired </b></h4>
<p>
  <code> @Inject </code> can also be used.
</p>
<p> 
  can be used for constructor / setter / property injection of the dependency bean into the dependent bean.
</p>
<p class="text-danger"> Autowiring list of values </p>

<p class="text-danger"> Autowiring a map </p>

<p class="text-danger"> Using Generics as Autowiring Qualifiers </p>

<p> <code> @Resource </code> can be used in place of @Autowired it looks like <code> @Autowired </code> is much more powerful.</p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong> @DependsOn </strong></h4>
<p> Used when one bean depends indirectly on other bean, if there is a direct dependency we can autowire.</p>
<p> Also used sometimes we can add <code> @Autowire </code> as we cannot modify the source code. </p>
<p> <b> Creation order </b> Dependent beans are created first. </p>
<p> <b> Destruction order </b> Independent beans are destroyed first. </p>

<pre class="language-java line-numbers"><code>
@Configuration
public class ClassD {

    @Bean("dataSource")
    public void createDataSource(){
        System.out.println("Creating datasource");
    }

    @Bean
    @DependsOn("dataSource")
    public void handleDataSource(){
        System.out.println("looking for the bean named datasource");
    }

}
</code></pre>

<p> Here until bean dataSource is created, bean handleDataSource will not be created as it depends on it.</p>

<pre class="language-sh line-numbers"><code>
Creating datasource
looking for the bean named datasource
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Lazy </b></h4>
<p> In general beans are created eagerly at startup </p>
<p> Works on Class, Method</p>
<p class="text-danger"> Works on Constructor, Field, Parameter</p>
<p> Lazy beans are initialized when they are requested </p>
<p> if another bean which is not lazyly initialized depends on the lazy initialized bean, then laziness is not applied </p>
<p> For a complete Laziness all the dependent beans should be maked with marked with <code> @Lazy </code> </p>

<pre class="language-java line-numbers"><code>
@Component
@Lazy
public class ClassLazy {

    public ClassLazy(){
        System.out.println("Constructor of ClassLazy");
    }

}
</code></pre>


<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><strong class="text-danger"> @Lookup </strong></h4>
<p> Also called Method Injection </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Scope </b></h4>
<p> Refer </p>
<p> takes argument on the type of the scope such as singleton, prototype </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @RequestScope </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @SessionScope </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @ApplicationScope </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @PostConstruct </b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @PreDestroy</b></h4>
<p> Refer </p>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Primary </b></h4>
<p> 
  Without @Primary Spring would fail as Spring would find 2 beans of the same type, So by adding @Primary to one of the bean, we can
  tell Spring to use that in such scenarios.
</p>


<pre class="language-java line-numbers"><code>
@Component
@Primary
public class Type1 implements CommonType {

    public Type1(){
        System.out.println(
                "Type1 constructor"
        );
    }
}

@Component
public class Type2 implements CommonType {

    public Type2(){
        System.out.println("Type 2 constructor");
    }
}

@Component
public class Type3 {

    @Autowired
    private CommonType c1;

    @PostConstruct
    public void m1(){
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "Type3{" +
                "c1=" + c1 +
                '}';
    }
}

</code></pre>

Type1 bean is autowired.
<pre class="language-java line-numbers"><code>
Type3{c1=com.ninjashore.sample.Components.Type1@df3b78}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Qualifier  </b></h4>
<p> In case Spring find 2 or more beans of the same type we can use <code> @Qualifier </code> to mention which bean to pick,
  also you need to name the bean accordingly, if you do not name the bean then Spring names the name with the regular convention of
  small letter as small case, for example in the below code though I did not give Type2 class a name Spring named it as type2 and
  autowired it.
</p>

<pre class="language-java line-numbers"><code>
@Component("type1")
public class Type1 implements CommonType {

    public Type1(){
        System.out.println(
                "Type1 constructor"
        );
    }
}

@Component
public class Type2 implements CommonType {

    public Type2(){
        System.out.println("Type 2 constructor");
    }
}

@Component
public class Type3 {

    @Autowired
    @Qualifier("type2")
    private CommonType c1;

    @PostConstruct
    public void m1(){
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "Type3{" +
                "c1=" + c1 +
                '}';
    }
}

</code></pre>

Type 2 bean is autowired.
<pre class="language-java line-numbers"><code>
Type3{c1=com.ninjashore.sample.Components.Type2@df4b72}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @PropertySource  </b></h4>
<p> 
  By default properties are looked at <mark> application.properties </mark>, but if you want to change to a new properties file then
  you can acheive with this <code> @PropertySource("classpath:<new-file-name>") </code>. Create the new file in <mark> resources </mark>
</p>

<pre class="language-java line-numbers"><code>

@SpringBootApplication()
@PropertySource("classpath:test.properties")
public class SampleApplication2 {
    public static void main(final String[] args) {
        SpringApplication.run(SampleApplication2.class, args);
    }
}
</code></pre>

<!------------------------------------------------------------------------------------------------------------------------->
<hr>

<h4><b> @Valid  </b></h4>
<p> 
  @valid looks for the property key at default location <mark> application.properties </mark> which can be changed by <code>
  @PropertySource </code>. To interpolate the value use <code> ${} </code>
</p>

<pre class="language-java line-numbers"><code>
@Component
public class ClassA2 {

    @Value("${p1}")
    private String p1;

    @PostConstruct
    public void m1(){
        System.out.println(this.p1);   /// Prints the value of p1 picked up application.properties.
    }
}
</code></pre>


<!------------------------------------------------------------------------------------------------------------------------->
<hr>
