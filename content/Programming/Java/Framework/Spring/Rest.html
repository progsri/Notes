<h2><strong> Rest </strong></h2>
<hr>

<p>
  Spring simply extend Spring MVC API for REST.
</p>
<p>
  use <code> @RestController </code> to mark the class that can handle REST calls. This will automatically map the json to the
  POJO if Jackson is on the classpath.
</p>

<hr>
<h4><strong> @RequestMapping </strong></h4>
<p>
  <code> @RequestMapping("path") </code>
</p>

<hr>
<h4><strong> @GetMapping </strong></h4>
<p>
  <code> @GetMapping("path") </code> only allows GET calls
</p>

<hr>
<h4><strong> @PathVariable </strong></h4>
In the below code id is the pathvariable

<pre class="language-java line-numbers"><code>

@RestController
@RequestMapping("/api")
public class Api{

 @GetMapping("/student/{id}")
  public String getValue(@PathVariable int id)

}

</code></pre>

<hr>
<h4><strong> ResponseEntity </strong></h4>
<p>
  <code> ResponseEntity </code> tells you pass the custom Response. use <code> new ResponseEntity&lt;&gt;(object, code)
  </code> where object is the custom POJO you want to send out as response and code is the HTTP Status code. 
</p>


<hr>
<h4><strong> Controller Specific Exception Handling - @ExceptionHandler </strong></h4>
<p>
  This works for general  <code> Exception.class </code> or custom exception. <b> This only works for a Controller only </b>
</p>

The below gets executed whenever there is any Exception.
<pre class="language-java line-numbers"><code>
 
 @ExceptionHandler
 public ResponseEntity<CustomError> method(Exception exp){
      CustomError err = new CustomError()
      
      //set the CustomError fields
      
      return new ResponseEntity<>(err, HttpStatusCode);
 }
  
</code></pre>

<hr>
<h4><strong> Global Exception Handling -  </strong></h4>

<hr>
<h4><strong> @ControllerAdvice  </strong></h4>




